// Code generated by go run generate-int.go.

// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a
// Modified BSD License that can be found in
// the LICENSE file.

package maps

import (
	"sync"

	"github.com/tmthrgd/atomics"
)

// Uint64 provides a map of atomic uint64s.
type Uint64 struct {
	m sync.Map // map[interface{}]*atomics.Uint64
}

// Retrieve returns the atomics.Uint64 associated with
// the given key or nil if it does not exist in the map.
func (m *Uint64) Retrieve(key interface{}) *atomics.Uint64 {
	v, ok := m.m.Load(key)
	if !ok {
		return nil
	}

	return v.(*atomics.Uint64)
}

// Insert inserts the atomics.Uint64 into the map for
// the given key.
func (m *Uint64) Insert(key interface{}, val *atomics.Uint64) {
	m.m.Store(key, val)
}

// Value returns the atomics.Uint64 associated with the
// given key or atomically inserts a new atomics.Uint64
// into the map if an entry did not exist in the map
// for the given key.
func (m *Uint64) Value(key interface{}) *atomics.Uint64 {
	v, ok := m.m.Load(key)
	if !ok {
		v, _ = m.m.LoadOrStore(key, new(atomics.Uint64))
	}

	return v.(*atomics.Uint64)
}

// Delete removes an atomics.Uint64 from the map.
func (m *Uint64) Delete(key interface{}) {
	m.m.Delete(key)
}

// Range calls f for each entry in the map. If f
// returns false Range stops iterating over the map.
func (m *Uint64) Range(f func(key interface{}, val *atomics.Uint64) bool) {
	m.m.Range(func(key, val interface{}) bool {
		return f(key, val.(*atomics.Uint64))
	})
}

// Load is a wrapper for Value(key).Load().
func (m *Uint64) Load(key interface{}) (val uint64) {
	return m.Value(key).Load()
}

// Store is a wrapper for Value(key).Store(val).
func (m *Uint64) Store(key interface{}, val uint64) {
	m.Value(key).Store(val)
}

// Swap is a wrapper for Value(key).Swap(new).
func (m *Uint64) Swap(key interface{}, new uint64) (old uint64) {
	return m.Value(key).Swap(new)
}

// CompareAndSwap is a wrapper for
// Value(key).CompareAndSwap(old, new).
func (m *Uint64) CompareAndSwap(key interface{}, old, new uint64) (swapped bool) {
	return m.Value(key).CompareAndSwap(old, new)
}

// Add is a wrapper for Value(key).Add(delta).
func (m *Uint64) Add(key interface{}, delta uint64) (new uint64) {
	return m.Value(key).Add(delta)
}

// Increment is a wrapper for Value(key).Increment().
func (m *Uint64) Increment(key interface{}) (new uint64) {
	return m.Value(key).Increment()
}

// Subtract is a wrapper for Value(key).Subtract(delta).
func (m *Uint64) Subtract(key interface{}, delta uint64) (new uint64) {
	return m.Value(key).Subtract(delta)
}

// Decrement is a wrapper for Value(key).Decrement().
func (m *Uint64) Decrement(key interface{}) (new uint64) {
	return m.Value(key).Decrement()
}

// Reset is a wrapper for Value(key).Reset().
func (m *Uint64) Reset(key interface{}) (old uint64) {
	return m.Value(key).Reset()
}
