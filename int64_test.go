// Code generated by go run generate-tests.go.

// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a
// Modified BSD License that can be found in
// the LICENSE file.

package atomics

import (
	"testing"
	"testing/quick"
)

func TestInt64Default(t *testing.T) {
	var c Int64
	if c.Load() != 0 {
		t.Fatal("invalid default value")
	}
}

func TestNewInt64(t *testing.T) {
	if NewInt64(0) == nil {
		t.Fatal("NewInt64 returned nil")
	}
}

func TestInt64UnsafeRaw(t *testing.T) {
	var c Int64
	if c.UnsafeRaw() == nil {
		t.Fatal("UnsafeRaw returned nil")
	}
}

func TestInt64Load(t *testing.T) {
	if err := quick.Check(func(v int64) bool {
		return NewInt64(v).Load() == v
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func TestInt64Store(t *testing.T) {
	if err := quick.Check(func(v int64) bool {
		var c Int64
		c.Store(v)
		return c.Load() == v
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func TestInt64Swap(t *testing.T) {
	if err := quick.Check(func(old, new int64) bool {
		c := NewInt64(old)
		return c.Swap(new) == old && c.Load() == new
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func TestInt64CompareAndSwap(t *testing.T) {
	if err := quick.Check(func(old, new int64) bool {
		c := NewInt64(old)
		return !c.CompareAndSwap(-old, new) &&
			c.Load() == old &&
			c.CompareAndSwap(old, new) &&
			c.Load() == new
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func TestInt64Add(t *testing.T) {
	if err := quick.Check(func(v, delta int64) bool {
		c := NewInt64(v)
		v += delta
		return c.Add(delta) == v && c.Load() == v
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func TestInt64Increment(t *testing.T) {
	if err := quick.Check(func(v int64) bool {
		c := NewInt64(v)
		v++
		return c.Increment() == v && c.Load() == v
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func TestInt64Subtract(t *testing.T) {
	if err := quick.Check(func(v, delta int64) bool {
		c := NewInt64(v)
		v -= delta
		return c.Subtract(delta) == v && c.Load() == v
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func TestInt64Decrement(t *testing.T) {
	if err := quick.Check(func(v int64) bool {
		c := NewInt64(v)
		v--
		return c.Decrement() == v && c.Load() == v
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func TestInt64Reset(t *testing.T) {
	if err := quick.Check(func(v int64) bool {
		c := NewInt64(v)
		return c.Reset() == v && c.Load() == 0
	}, nil); err != nil {
		t.Fatal(err)
	}
}

func BenchmarkNewInt64(b *testing.B) {
	for n := 0; n < b.N; n++ {
		NewInt64(0)
	}
}

func BenchmarkInt64Load(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.Load()
	}
}

func BenchmarkInt64Store(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.Store(4) // RFC 1149.5 specifies 4 as the standard IEEE-vetted random number.
	}
}

func BenchmarkInt64Swap(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.Swap(4) // RFC 1149.5 specifies 4 as the standard IEEE-vetted random number.
	}
}

func BenchmarkInt64CompareAndSwap(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.CompareAndSwap(0, 0)
	}
}

func BenchmarkInt64Add(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.Add(4) // RFC 1149.5 specifies 4 as the standard IEEE-vetted random number.
	}
}

func BenchmarkInt64Increment(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.Increment()
	}
}

func BenchmarkInt64Subtract(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.Subtract(4) // RFC 1149.5 specifies 4 as the standard IEEE-vetted random number.
	}
}

func BenchmarkInt64Decrement(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.Decrement()
	}
}

func BenchmarkInt64Reset(b *testing.B) {
	var v Int64

	for n := 0; n < b.N; n++ {
		v.Reset()
	}
}
