// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a
// Modified BSD License that can be found in
// the LICENSE file.

// +build ignore

package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	for _, typ := range []struct {
		Type, Name, Atomic, AtomicType, MathName string
		Bitsize                                  int
	}{
		{"float32", "Float32", "Uint32", "uint32", "Float32", 32},
		{"float64", "Float64", "Uint64", "uint64", "Float64", 64},
	} {
		f, err := os.Create(typ.Type + ".go")
		if err != nil {
			log.Fatal(err)
		}

		if err = tmpl.Execute(f, typ); err != nil {
			log.Fatal(err)
		}

		f.Close()
	}
}

var tmpl = template.Must(template.New("").Parse(`// Code generated by go run generate-float.go.

// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a
// Modified BSD License that can be found in
// the LICENSE file.

package atomics

import (
	"math"
	"strconv"
	"sync/atomic"
)

// {{.Name}} provides an atomic {{.Type}}.
type {{.Name}} struct {
	noCopy noCopy
	val    {{.AtomicType}}
}

// New{{.Name}} returns an atomic {{.Type}} with a given value.
func New{{.Name}}(val {{.Type}}) *{{.Name}} {
	return &{{.Name}}{
		val: math.{{.MathName}}bits(val),
	}
}

// Raw returns a pointer to the {{.Type}}.
//
// It is only safe to access the pointer with methods from the
// sync/atomic package. Use caution if manually dereferencing.
//
// This returns the underlying {{.AtomicType}}, to convert this
// to and from a {{.Type}}, use math.{{.MathName}}frombits
// and math.{{.MathName}}bits respectively.
func (v *{{.Name}}) Raw() *{{.AtomicType}} {
	return &v.val
}

// Load returns the value of the {{.Type}}.
func (v *{{.Name}}) Load() (val {{.Type}}) {
	return math.{{.MathName}}frombits(atomic.Load{{.Atomic}}(&v.val))
}

// Store sets the value of the {{.Type}}.
func (v *{{.Name}}) Store(val {{.Type}}) {
	atomic.Store{{.Atomic}}(&v.val, math.{{.MathName}}bits(val))
}

// Swap sets the value of the {{.Type}} and returns the old value.
func (v *{{.Name}}) Swap(new {{.Type}}) (old {{.Type}}) {
	return math.{{.MathName}}frombits(atomic.Swap{{.Atomic}}(&v.val, math.{{.MathName}}bits(new)))
}

// CompareAndSwap sets the value of the {{.Type}} to new but only
// if it currently has the value old. It returns true if the swap
// succeeded.
func (v *{{.Name}}) CompareAndSwap(old, new {{.Type}}) (swapped bool) {
	return atomic.CompareAndSwap{{.Atomic}}(&v.val, math.{{.MathName}}bits(old), math.{{.MathName}}bits(new))
}

// Add adds delta to the {{.Type}}.
func (v *{{.Name}}) Add(delta {{.Type}}) (new {{.Type}}) {
	for {
		old := atomic.Load{{.Atomic}}(&v.val)
		new := math.{{.MathName}}frombits(old) + delta

		if atomic.CompareAndSwap{{.Atomic}}(&v.val, old, math.{{.MathName}}bits(new)) {
			return new
		}
	}
}

// Increment is a wrapper for Add(1).
func (v *{{.Name}}) Increment() (new {{.Type}}) {
	return v.Add(1)
}

// Subtract is a wrapper for Add(-delta)
func (v *{{.Name}}) Subtract(delta {{.Type}}) (new {{.Type}}) {
	return v.Add(-delta)
}

// Decrement is a wrapper for Add(-1).
func (v *{{.Name}}) Decrement() (new {{.Type}}) {
	return v.Add(-1)
}

// Reset is a wrapper for Swap(0).
func (v *{{.Name}}) Reset() (old {{.Type}}) {
	return v.Swap(0)
}

// String implements fmt.Stringer.
func (v *{{.Name}}) String() string {
	return strconv.FormatFloat(float64(v.Load()), 'g', -1, {{.Bitsize}})
}
`))
