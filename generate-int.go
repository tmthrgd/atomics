// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a
// Modified BSD License that can be found in
// the LICENSE file.

// +build ignore

package main

import (
	"log"
	"os"
	"text/template"
)

func main() {
	for _, typ := range []struct {
		Type, Name, Atomic string
		Unsigned           bool
	}{
		{"int32", "Int32", "Int32", false},
		{"int64", "Int64", "Int64", false},
		{"uint32", "Uint32", "Uint32", true},
		{"uint64", "Uint64", "Uint64", true},
	} {
		f, err := os.Create(typ.Type + ".go")
		if err != nil {
			log.Fatal(err)
		}

		if err = tmpl.Execute(f, typ); err != nil {
			log.Fatal(err)
		}

		f.Close()
	}
}

var tmpl = template.Must(template.New("impl").Parse(`// Code generated by go run generate-int.go.

// Copyright 2017 Tom Thorogood. All rights reserved.
// Use of this source code is governed by a
// Modified BSD License that can be found in
// the LICENSE file.

package atomics

import (
	"strconv"
	"sync/atomic"
)

// {{.Name}} provides an atomic {{.Type}}.
type {{.Name}} struct {
	noCopy noCopy
	val    {{.Type}}
}

// New{{.Name}} returns an atomic {{.Type}} with a given value.
func New{{.Name}}(val {{.Type}}) *{{.Name}} {
	return &{{.Name}}{val: val}
}

// Raw returns a pointer to the {{.Type}}.
//
// It is only safe to access the pointer with methods from the
// sync/atomic package. Use caution if manually dereferencing.
func (v *{{.Name}}) Raw() *{{.Type}} {
	return &v.val
}

// Load returns the value of the {{.Type}}.
func (v *{{.Name}}) Load() (val {{.Type}}) {
	return atomic.Load{{.Atomic}}(&v.val)
}

// Store sets the value of the {{.Type}}.
func (v *{{.Name}}) Store(val {{.Type}}) {
	atomic.Store{{.Atomic}}(&v.val, val)
}

// Swap sets the value of the {{.Type}} and returns the old value.
func (v *{{.Name}}) Swap(new {{.Type}}) (old {{.Type}}) {
	return atomic.Swap{{.Atomic}}(&v.val, new)
}

// CompareAndSwap sets the value of the {{.Type}} to new but only
// if it currently has the value old. It returns true if the swap
// succeeded.
func (v *{{.Name}}) CompareAndSwap(old, new {{.Type}}) (swapped bool) {
	return atomic.CompareAndSwap{{.Atomic}}(&v.val, old, new)
}

// Add adds delta to the {{.Type}}.
func (v *{{.Name}}) Add(delta {{.Type}}) (new {{.Type}}) {
	return atomic.Add{{.Atomic}}(&v.val, delta)
}

// Increment is a wrapper for Add(1).
func (v *{{.Name}}) Increment() (new {{.Type}}) {
	return v.Add(1)
}

{{if .Unsigned -}}

// Subtract subtracts delta from the {{.Type}}.
func (v *{{.Name}}) Subtract(delta {{.Type}}) (new {{.Type}}) {
	return atomic.Add{{.Atomic}}(&v.val, ^(delta - 1))
}

// Decrement is a wrapper for Subtract(1).
func (v *{{.Name}}) Decrement() (new {{.Type}}) {
	return v.Subtract(1)
}

{{- else -}}

// Subtract is a wrapper for Add(-delta)
func (v *{{.Name}}) Subtract(delta {{.Type}}) (new {{.Type}}) {
	return v.Add(-delta)
}

// Decrement is a wrapper for Add(-1).
func (v *{{.Name}}) Decrement() (new {{.Type}}) {
	return v.Add(-1)
}

{{- end}}

// Reset is a wrapper for Swap(0).
func (v *{{.Name}}) Reset() (old {{.Type}}) {
	return v.Swap(0)
}

// String implements fmt.Stringer.
func (v *{{.Name}}) String() string {
{{- if .Unsigned}}
	return strconv.FormatUint(uint64(v.Load()), 10)
{{- else}}
	return strconv.FormatInt(int64(v.Load()), 10)
{{- end}}
}
`))
